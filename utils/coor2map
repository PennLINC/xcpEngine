#!/usr/bin/env bash

###################################################################
#  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  #
###################################################################

###################################################################
# Function for converting a seed library into a network
###################################################################

###################################################################
# Constants
# "orientation" is the orientation enforced by AFNI's 3dcalc
###################################################################
source ${XCPEDIR}/core/constants
source ${XCPEDIR}/core/functions/library.sh

###################################################################
# Usage function
###################################################################
Usage(){
cat << endstream
___________________________________________________________________


Usage: coor2map -i <input> -o <output> <options>

`basename $0` receives an octothorpe-delimited seed index
  as input and creates a network map image as an output.

Compulsory arguments:
 -i : Input seed library
      An octothorpe/hash- (#) delimited list of seed names,
      non-overlapping coordinates, and potentially radii."

 -o : Output network"
      The path to the file where the output network will
      be written."

Optional arguments:"
 -r : Override radius. If this argument is passed to the
      conversion script, then this radius will take the place
      of any voxel radii defined in the seed library.

 -t : Template image [default MNI 2mm]
      The path to an image file that defines the coordinate
      space used in the seed library.

 -x : Trace"
      If this flag is set, then any commands called by the
      `basename $0` routine will be explicitly printed to the
      console or log.


endstream
}

###################################################################
# Define defaults
###################################################################
radius_default=5
template=${FSLDIR}/data/standard/MNI152_T1_2mm_brain
###################################################################
# Parse arguments
###################################################################
while getopts "i:o:t:r:x" OPTION
   do
   case $OPTION in
   i)
      sclib=${OPTARG}
      ;;
   o)
      out=${OPTARG}
      ;;
   t)
      template=${OPTARG}
      ! is_image ${template} && Usage && exit
      imgpath=${template}
      ;;
   r)
      radius=${OPTARG}
      ! is+numeric ${radius} && Usage && exit
      ;;
   x)
      set -x
      ;;
   *)
      echo "Option not recognised: ${OPTARG}"
      Usage
      exit
   esac
done
shift $((OPTIND-1))
###################################################################
# Ensure that all compulsory arguments have been defined
###################################################################
[[ -z ${sclib} ]]    && Usage && exit
[[ -z ${out} ]]      && Usage && exit
[[ -z ${template} ]] && Usage && exit





###################################################################
# Prime temporary command file.
###################################################################
subroutine                    @u.1
rng=$(date +%N)
ctemp=${rng}coor2map~TEMP~.sh
[[ -n ${TMPDIR} ]] && ctemp=${TMPDIR}/${ctemp}





###################################################################
# Determine the orientation of the coordinate template.
# Despite what it might say in the documentation, AFNI's 3dcalc
# strictly *enforces* LAI orientation.
#
# This is no longer necessary, as this function now operates
# directly in voxel space.
###################################################################
subroutine                    @u.2
x_sign='-'
y_sign='-'
z_sign='-'





###################################################################
# Obtain conversion factors for radii: mm to vox
###################################################################
subroutine                    @u.3
xvox=$(exec_fsl fslval $template pixdim1)
yvox=$(exec_fsl fslval $template pixdim2)
zvox=$(exec_fsl fslval $template pixdim3)





load_atlas ${sclib}

space=$(grep -i '^SPACE::' ${sclib}|cut -d':' -f3)

nodeidx=1
for node in ${atlas[@]}
   do
   ################################################################
   # Parse node information
   ################################################################
   subroutine                 @u.4
   atlas_parse ${node}
   ################################################################
   # Move to voxel coordinates
   #
   # TODO
   # Some redundant calculations here are (rather insignificantly)
   # slowing the computation
   ################################################################
   res=$(grep -i '^SPACE::' ${sclib}|cut -d":" -f5)
   if [[ -z ${res} ]]
      then
      subroutine              @u.5
      a_coor=$(echo ${a_coor//,/ }\
            |exec_fsl std2imgcoord -img ${space} -std ${space} -vox)
      xres=$(exec_fsl fslval $space pixdim1)
      yres=$(exec_fsl fslval $space pixdim2)
      zres=$(exec_fsl fslval $space pixdim3)
      res=(${xres} ${yres} ${zres})
   fi
   if [[ ${space} == "MNI152" ]]
      then
      subroutine              @u.6
      a_coor=$(exec_fsl mni2vox ${a_coor} 1)
      res=(1 1 1)
   fi
   subroutine                 @u.7
   xres=${res[0]}
   yres=${res[1]}
   zres=${res[2]}
   x2res=$(arithmetic ${xvox}/${xres})
   y2res=$(arithmetic ${yvox}/${yres})
   z2res=$(arithmetic ${zvox}/${zres})
   ################################################################
   # Determine radius: Order of precedence is:
   #  (1) User input
   #  (2) sclib file
   #  (3) default value
   ################################################################
   rad=${radius}
   if [[ -z ${rad} ]]
      then
      subroutine              @u.8
      rad=${a_radius}
   fi
   if [[ -z ${rad} ]]
      then
      subroutine              @u.9
      rad=${radius_default}
   fi

   ################################################################
   # Add ROI to network
   # Any previous, overlapping ROIs will be overwritten; only a
   # hard parcellation is supported
   ################################################################
   subroutine                 @u.10
   coor=(${a_coor//,/ })
   xcoor=$(arithmetic ${coor[0]}/${x2res})
   ycoor=$(arithmetic ${coor[1]}/${y2res})
   zcoor=$(arithmetic ${coor[2]}/${z2res})
   
   ################################################################
   # Scale radius to the coordinate space
   ################################################################
   subroutine                 @u.11
   xrad=$(arithmetic ${rad}/${xvox})
   yrad=$(arithmetic ${rad}/${yvox})
   zrad=$(arithmetic ${rad}/${zvox})
   xradsq=$(arithmetic ${xrad}^2)
   yradsq=$(arithmetic ${yrad}^2)
   zradsq=$(arithmetic ${zrad}^2)
   
   ################################################################
   # Generate a solid ellipsoid (a sphere in true physical space)
   #  * Note that each additional node wraps the expression from
   #    all previous nodes in a multiplier that zeroes the values
   #    inside the new node before the new node is added. This
   #    will result in a much slower module, but is necessary to
   #    ensure that there is no overlap.
   ################################################################
   subroutine                 @u.12
   nodeexpr="step(1-(i${x_sign}${xcoor})*(i${x_sign}${xcoor})/${xradsq}-(j${y_sign}${ycoor})*(j${y_sign}${ycoor})/${yradsq}-(k${z_sign}${zcoor})*(k${z_sign}${zcoor})/${yradsq})"
   if [[ -z ${netexpr} ]]
      then
      subroutine              @u.13.1
      netexpr=${nodeexpr}
   else
      subroutine              @u.13.2
      netexpr="(-1*${nodeexpr}+1)*(${netexpr}) + ${nodeidx}*${nodeexpr}"
   fi
   
   ################################################################
   # If expressions get too long, 3dcalc does not like the input,
   # so networks with a large number of nodes (e.g. Power 264)
   # will need to be split into 35-node subnetworks, then
   # aggregated in the final step
   ################################################################
   if (( $(( ${nodeidx} % 35 )) == 0 ))
      then
      subroutine              @u.14
      exec_sys rm -f ${ctemp}
      echo "#!/usr/bin/env bash" >> ${ctemp}
      echo "exec_afni 3dcalc -overwrite -a ${imgpath} -expr '${netexpr}' -prefix ${out}.nii.gz" >> ${ctemp}
      exec_sys chmod 755 ${ctemp}
      exec_sys bash ${ctemp}
      imgpath=${out}.nii.gz
      netexpr=a
   fi
   
   nodeidx=$(( ${nodeidx} + 1 ))
   
done

###################################################################
# Collate all subnetwork maps
###################################################################
subroutine                    @u.15
exec_sys rm -f ${ctemp}
echo "#!/usr/bin/env bash" >> ${ctemp}
echo "exec_afni 3dcalc -overwrite -a ${imgpath} -expr '${netexpr}' -prefix ${out}.nii.gz" >> ${ctemp}
exec_sys chmod 755 ${ctemp}
exec_sys bash ${ctemp}

###################################################################
# Delete all intermediate files
###################################################################
exec_sys rm -f ${ctemp}
