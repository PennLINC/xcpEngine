#!/usr/bin/env bash

###################################################################
#  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  #
###################################################################

###################################################################
# This is a wrapper around antsApplyTransformToPoints that won't
# require you to kill yourself over image orientations
###################################################################

###################################################################
# Constants
# "orientation" is the orientation enforced by ANTs/ITK
###################################################################
source ${XCPEDIR}/core/constants
source ${XCPEDIR}/core/functions/library.sh

###################################################################
# Usage function
###################################################################
Usage(){
cat << endstream
___________________________________________________________________


Usage: pointTransform -i <input> <options>

Compulsory arguments:
 -i : Input
      This can either be a seed coordinate library (.sclib)
      file or a hash (#)-delimited list of comma-delimited
      coordinate sets, e.g. '1,3,-7#2,6,6'

 -s : Coordinate space image [default MNI 2mm]
      The path to an image file that defines the coordinate
      space in which input coordinates are initially
      situated.

 -r : Coordinate space reference [default MNI 2mm]
      The path to an image file that defines the coordinate
      space into which coordinates are to be transformed.

 -t : Paths to the INVERSES of the transforms to be applied
      to the input. You may either pass each as a separate
      flag, or pass them as a hash (#)-delimited list.
      Transforms will be composed into a diffeomorphism in
      the order that they are passed.

Optional arguments:
 -v : Output voxel coordinates
      If this flag is set, then the outputs of transforms
      will be in voxel space rather than mm space.

 -l : Input voxel coordinates
      If this flag is set, then the input coordinates will
      be understood to be in voxel space.

 -x : Trace
      If this flag is set, then any commands called by the
      pointTransform routine will be explicitly printed to
      the console or log.


endstream
}

###################################################################
# Define defaults
###################################################################
template=${FSLDIR}/data/standard/MNI152_T1_2mm_brain
reference=${FSLDIR}/data/standard/MNI152_T1_2mm_brain
sclib=0
VOXEL=0
###################################################################
# Parse arguments
###################################################################
while getopts "i:s:t:r:vlx" OPTION
   do
   case $OPTION in
   i)
      coors=${OPTARG}
      ;;
   s)
      template=${OPTARG}
      ! is_image ${template} && Usage && exit
      ;;
   t)
      [[ -z ${transforms} ]] \
         && transforms=${OPTARG} \
         || transforms="${transforms}#${OPTARG}"
      ;;
   r)
      reference=${OPTARG}
      ! is_image ${reference} && Usage && exit
      ;;
   v)
      VOXEL=1
      ;;
   l)
      VOXIN=1
      ;;
   x)
      set -x
      ;;
   *)
      echo "Option not recognised: ${OPTARG}"
      Usage
      exit
   esac
done
shift $((OPTIND-1))
###################################################################
# Ensure that all compulsory arguments have been defined
###################################################################
[[ -z ${coors} ]] && Usage && exit
[[ -z ${template} ]] && Usage && exit
[[ -z ${reference} ]] && Usage && exit
[[ -z ${transforms} ]] && Usage && exit





###################################################################
# Determine whether the input is a coordinates library or a
# coordinates list.
# Load the coordinates if they are in a library
###################################################################
if [[ -s ${coors} ]]
   then
   subroutine                 @u.1
   sclib=1
   sclibpath=${coors}
   load_atlas ${coors}
else
   subroutine                 @u.2
   atlas=( ${coors//#/ } )
fi
coors=( ${atlas[@]} )





###################################################################
# Parse the transform list. ANTs applies transforms in the reverse
# order that they are passed.
###################################################################
subroutine                    @u.3
transforms=$(echo $transforms|sed s@'#'@' '@g)
for transform in ${transforms}
   do
   antsXFM="-t ${transform} ${antsXFM}"
done





###################################################################
# Determine the orientation of the coordinate template.
# ANTs strictly enforces RAI orientation.
###################################################################
subroutine                    @u.4
x_sign=1
y_sign=1
z_sign=1
orient=$(exec_afni @GetAfniOrient ${template})
xorient=${orient:0:1}
yorient=${orient:1:1}
zorient=${orient:2:1}
rxorient=${ORIENTATION_ITK:0:1}
ryorient=${ORIENTATION_ITK:1:1}
rzorient=${ORIENTATION_ITK:2:2}
[[ ${xorient} != ${rxorient} ]] \
   && x_sign=-1
[[ ${yorient} != ${ryorient} ]] \
   && y_sign=-1
[[ ${zorient} != ${rzorient} ]] \
   && z_sign=-1





###################################################################
# Initialise an ANTs coordinate csv
###################################################################
subroutine                    @u.5
rng=$(date +%N)
ctemp=${rng}COORD~TEMP~
[[ -n ${TMPDIR} ]] && ctemp=${TMPDIR}/${ctemp}
exec_sys rm -f ${ctemp}.csv
echo x,y,z,t >> ${ctemp}.csv





###################################################################
# Iterate through all coordinates and write them into the to-be-
# transformed csv
###################################################################
for coor in ${coors[@]}
   do
   subroutine                 @u.6
   [[ ${sclib} == 1 ]] && atlas_parse ${coor} && coor=${a_coor}
   ################################################################
   # Move out of voxel space
   ################################################################
   coor=${coor//,/ }
   if [[ ${space} == VOXEL ]] || [[ ${VOXIN} == 1 ]]
      then
      subroutine              @u.7
      coor=$(echo ${coor}|\
         exec_fsl img2stdcoord \
         -img ${template} \
         -std ${template})
   fi
   subroutine                 @u.8
   coor=( ${coor} )
   xcoor=${coor[0]}
   ycoor=${coor[1]}
   zcoor=${coor[2]}
   ################################################################
   # Reflect into the realm of RAI, if necessary
   ################################################################
   if [[ ${x_sign} == -1 ]]
      then
      subroutine              @u.9.1
      xcoor=$(arithmetic -1*${xcoor})
   fi
   if [[ ${y_sign} == -1 ]]
      then
      subroutine              @u.9.2
      ycoor=$(arithmetic -1*${ycoor})
   fi
   if [[ ${z_sign} == -1 ]]
      then
      subroutine              @u.9.3
      zcoor=$(arithmetic -1*${zcoor})
   fi
   ################################################################
   # Write the coordinates into the csv
   ################################################################
   echo ${xcoor},${ycoor},${zcoor},0 >> ${ctemp}.csv
done





###################################################################
# Transform all coordinates
###################################################################
subroutine                    @u.10
${ANTSPATH}/antsApplyTransformsToPoints \
   -d 3 \
   -i ${ctemp}.csv \
   ${antsXFM} \
   -o ${ctemp}out.csv





###################################################################
# Iterate through all coordinates and write them to stdout
# in sclib format
###################################################################
subroutine                    @u.11
coorsxfm=$(tail -n +2 ${ctemp}out.csv)
coorsxfm=(${coorsxfm})
if [[ ${VOXEL} == 1 ]]
   then
   subroutine                 @u.12
   xres=$(exec_fsl fslval ${reference} pixdim1)
   yres=$(exec_fsl fslval ${reference} pixdim2)
   zres=$(exec_fsl fslval ${reference} pixdim3)
   space="VOXEL::${xres},${yres},${zres}::${reference}"
else
   subroutine                 @u.13
   space=${reference}
fi
echo "SPACE::${space}"
for ((i=0;i<${#coorsxfm[@]};i++))
   do
   subroutine                 @u.14
   coor=${coors[i]}
   coor_xfm=${coorsxfm[i]}
   unset a_name a_radius a_coor a_type
   if [[ ${sclib} == 1 ]]
      then
      subroutine              @u.15
      atlas_parse ${coor}
   fi
   coor_xfm=( ${coor_xfm//,/ } )
   xcoor=${coor_xfm[0]}
   ycoor=${coor_xfm[1]}
   zcoor=${coor_xfm[2]}
   ################################################################
   # Return from the realm of RAI, if necessary
   ################################################################
   if [[ ${x_sign} == -1 ]]
      then
      subroutine              @u.16.1
      xcoor=$(arithmetic -1*${xcoor})
   fi
   if [[ ${y_sign} == -1 ]]
      then
      subroutine              @u.16.2
      ycoor=$(arithmetic -1*${ycoor})
   fi
   if [[ ${z_sign} == -1 ]]
      then
      subroutine              @u.16.3
      zcoor=$(arithmetic -1*${zcoor})
   fi
   coor=${xcoor},${ycoor},${zcoor}
   ################################################################
   # Convert the output to voxel space if requested
   ################################################################
   if [[ ${VOXEL} == 1 ]]
      then
      subroutine              @u.17
      coor=$(echo ${coor//,/ }|\
            ${FSLDIR}/bin/std2imgcoord \
            -img ${reference} \
            -std ${reference} \
            -vox)
   fi
   ################################################################
   # Print the output
   ################################################################
   [[ -z ${a_name} ]] && a_name=Region$(($i + 1))
   echo '#'${a_name}'#'${coor}'#'${a_radius}
done




rm -f ${ctemp}*.csv
