#!/usr/bin/env bash

###################################################################
#  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  #
###################################################################

###################################################################
# Generalised function for temporally filtering 4D BOLD timeseries
# data
###################################################################

###################################################################
# Constants
###################################################################
source ${XCPEDIR}/core/constants
source ${XCPEDIR}/core/functions/library.sh

###################################################################
# Usage function
###################################################################
Usage(){
cat << endstream
___________________________________________________________________


Usage: `basename $0` -i <input> -o <output> <options>

Compulsory arguments:
 -i : Input timeseries
      The 4D timeseries to which the temporal filter is to
      be applied.

 -o : Output timeseries
      The path to the file where the filtered timeseries
      will be written.

Optional arguments:
 -f : Temporal filter mode [default fft]
      Input can be any of 'gaussian', 'fft', 'butterworth',
      'chebyshev1', 'chebyshev2', or 'elliptic'.
       * FFT-based filters [default] use a fast Fourier
         transform to attenuate frequencies. An FFT-based
         filter may not be suitable for use in designs that
         incorporate iterative motion censoring, since
         it will include interpolated frequencies in its
         calculations.
       * A Gaussian filter uses Gaussian-weighted least-
         squares
       * Chebyshev and elliptic filters more ideally
         discriminate accepted and attenuated frequencies
         than do Butterworth filters, but they introduce
         ripples in either the passband (chebyshev1),
         stopband (chebyshev2), or both (elliptic) that
         result in some signal distortion.

 -h : Highpass frequency [default 0.01]
      The cutoff frequency below which all signal will be
      removed from the timeseries, in Hz. To create a
      bandpass filter, specify a lowpass frequency that is
      higher than the highpass frequency.

 -l : Lowpass frequency [default nyquist]
      The cutoff frequency above which all signal will be
      removed from the timeseries, in Hz.

 -m : Mask
      Filtering is computed only within the specified
      binary mask.

 -n : Temporal mask with interpolation
      Filtering is computed only within the specified
      temporal mask. Outside of the temporal mask, the values
      of the timeseries are interpolated so as to eliminate
      the influence of masked-out time points on the processed
      timeseries (following Power et al., 2014).

 -k : Temporal mask without interpolation
      Discard volumes from the temporal mask, but do not
      interpolate over volumes to be censored. Use this option
      if, for instance, you are using an old scrubbing-based
      processing pipeline.

 -r : Filter order [default 1]
      The filter order indicates the number of input samples
      taken under consideration when generating an output
      signal. In general, using a higher-order filter will
      result in a sharper cutoff between accepted and
      attenuated frequencies. For a gentler filter, use a
      lower order.
      (Affects only Butterworth, Chebyshev, and elliptic
      filters.)

 -d : Filter direction [default 2]
      The filter direction indicates whether the input signal
      should be processed in the forward direction only [-d 1]
      or in both forward and reverse directions [-d 2].
      (Affects only Butterworth, Chebyshev, and elliptic
      filters.)

 -p : Pass band ripple [default 1]
      Chebyshev I and elliptic filters allow for sharper
      discrimination between accepted and attenuated
      frequencies at the cost of a 'ripple' in the pass band.
      This ripple results in somewhat uneven retention of
      pass-band frequencies.
      (Affects only Chebyshev I and elliptic filters)

 -s : Stop band ripple [default 1]
      Chebyshev II and elliptic filters allow for sharper
      discrimination between accepted and attenuated
      frequencies at the cost of a 'ripple' in the stop band.
      This ripple results in somewhat uneven removal of
      stop-band frequencies.
      (Affects only Chebyshev II and elliptic filters)

 -v : Discard volumes [default 0]
      Application of certain filters may result in extreme
      values at the beginnings and ends of timeseries; these
      values may be removed by discarding initial (for all
      filters) and final (for forward-reverse filters) time
      points.
      (Should not be used for FFT or Gaussian filters)

 -x : Index of derivative images
      Path to a file containing any derivative images
      generated from the primary BOLD timeseries. The file
      text should match the format:
           #NAME_OF_IMAGE1#PATH_TO_IMAGE1
           #NAME_OF_IMAGE2#PATH_TO_IMAGE2
           ...
      If any images in the derivatives file have the same
      number of volumes as the primary BOLD timeseries,
      then the same filtering procedure that was applied
      to the primary BOLD timeseries will be applied to
      that derivative image.

 -1 : 1D timeseries
      A comma separated list of paths to files containing
      one-dimensional timeseries. Each column in the file
      should represent a separate timeseries, and each row
      should represent a separate time point; the number of
      rows must equal the number of volumes present in the
      primary BOLD timeseries. The same filtering regime
      that was applied to the primary BOLD timeseries will
      be applied to each column of each 1D file

 -t : Trace
      If this flag is set, then any commands called by the
      tfilter routine will be explicitly printed to the
      console or log.


endstream
}





###################################################################
# Define defaults
###################################################################
filter=fft
hipass=0.01
lopass=nyquist
order=1
pass=2
rpass=1
rstop=1
dvol=0
tmask=ones
tmaskcut=ones
ntrue=0
ktrue=-1
###################################################################
# Parse arguments
###################################################################
while getopts "i:o:f:h:l:m:n:k:r:d:p:s:v:x:1:t" OPTION
   do
   case $OPTION in
   i)
      image=${OPTARG}
      ! is_image ${image} && Usage && exit
      ;;
   o)
      out=${OPTARG}
      out_root=$(exec_fsl remove_ext ${out})
      ;;
   f)
      filter=${OPTARG}
      if [[ ${filter} != gaussian ]] \
      && [[ ${filter} != fft ]] \
      && [[ ${filter} != butterworth ]] \
      && [[ ${filter} != chebyshev1 ]] \
      && [[ ${filter} != chebyshev2 ]] \
      && [[ ${filter} != elliptic ]]
         then
         echo "Unrecognised filter mode: ${filter}."
         Usage
         exit
      fi
      ;;
   h)
      hipass=${OPTARG}
      ! is+numeric ${hipass} && Usage && exit
      ;;
   l)
      lopass=${OPTARG}
      ! is+numeric ${lopass} \
         && [[ ${lopass} != nyquist ]] \
         && Usage \
         && exit
      ;;
   m)
      mask=${OPTARG}
      ! is_image ${mask} && Usage && exit
      ;;
   n)
      tmask=${OPTARG}
      tmaskcut=${OPTARG}
      ntrue=1
      ;;
   k)
      tmaskcut=${OPTARG}
      ktrue=1
      ;;
   r)
      order=${OPTARG}
      ! is+integer ${order} && Usage && exit
      ;;
   d)
      pass=${OPTARG}
      (( ${pass} != 1 )) \
         && (( ${pass} != 2 )) \
         && Usage \
         && exit
      ;;
   p)
      rpass=${OPTARG}
      ! is+numeric ${rpass} && Usage && exit
      ;;
   s)
      rstop=${OPTARG}
      ! is+numeric ${rstop} && Usage && exit
      ;;
   v)
      dvol=${OPTARG}
      ! is+integer ${dvol} && Usage && exit
      ;;
   x)
      derivsList=${OPTARG}
      derivatives=$(cat ${derivsList})
      for derivative in ${derivatives_floating}
         do
         derivative_parse ${derivative}
         is_image ${d_path} && derivatives="${derivatives} ${derivative}"
      done
      ;;
   1)
      tslist=${OPTARG}
      ;;
   t)
      set -x
      ;;
   *)
      echo "Option not recognised: ${OPTARG}"
      Usage
      exit
   esac
done
###################################################################
# Ensure that all compulsory arguments have been defined
###################################################################
[[ -z ${image} ]]  && Usage && exit
[[ -z ${out} ]]    && Usage && exit
[[ -z ${filter} ]] && Usage && exit
if (( ${ntrue} == ${ktrue} ))
   then
   echo "You may only specify one of -n and -k"
   exit
fi
###################################################################
# Ensure that all 1D timeseries (including the temporal mask) have
# the same number of volumes as the primary BOLD timeseries
###################################################################
nvol=$(exec_fsl fslnvols ${image})
if [[ ${tmask} != ones ]]
   then
   cvol=$(wc -l < ${tmask})
else
   cvol=${nvol}
fi
if (( ${nvol} != ${cvol} ))
   then
   echo "Volume mismatch: temporal mask"
   exit
fi
[[ -n ${tslist} ]] && tslist=${tslist//,/ }
for ts in ${tslist}
   do
   cvol=$(wc -l < ${ts})
   if (( ${nvol} != ${cvol} ))
      then
      echo "Volume mismatch: ${ts}"
      exit
   fi
done
###################################################################
# Compute the repetition time. This is required for all filters.
###################################################################
t_rep=$(exec_fsl fslval ${image} pixdim4)





###################################################################
# 1. Interpolate over masked-out epochs, if a temporal mask has
#    been provided.
###################################################################
if [[ ${tmask} != ones ]]
   then
   subroutine     @u.1a Interpolating over masked-out epochs...
   subroutine     @u.1b This will be slow
   exec_xcp \
      interpolate.R \
      -i "${image}" \
      -m "${mask}" \
      -t "${tmask}" \
      -o "${out_root}_interpol.nii.gz"
   ################################################################
   # Update pointers to indicate the post-interpolation image
   ################################################################
   image=${out_root}_interpol.nii.gz
fi





###################################################################
# Branch to the subroutine appropriate for the filter specified by
# user input
###################################################################
case ${filter} in





gaussian)
   subroutine                 @u.2
   genfilt=0
   is_image ${mask} && maskcall="-mas ${mask}"
   ################################################################
   # 2a. Filter the primary 4D timeseries.
   #---------------------------------------------------------------
   #   * First, convert the cutoff frequencies from Hz (cycles per
   #     second) to cycles per repetition.
   #   * Convert from frequency cutoff (in Hz) to cycle cutoff
   #     (in s).
   #   * Then, determine how many cycles of the cutoff per
   #     repetition.
   ################################################################
   hpw=$(arithmetic 1/${hipass})
   hpf=$(arithmetic ${hpw}/${t_rep}/2)
   ################################################################
   #   * Repeat for the lowpass frequency with the following
   #     exception: Set lowpass frequency to -1 (no attenuation)
   #     if the lowpass frequency is set to Nyquist.
   ################################################################
   if [[ ${lopass} == nyquist ]]
      then
      subroutine              @u.2.1
      lpf=-1
   else
      subroutine              @u.2.2
      lpw=$(arithmetic 1/${lopass})
      lpf=$(arithmetic ${lpw}/${t_rep}/2)
   fi
   ################################################################
   #   * With that, it is possible to apply the filter through
   #     fslmaths.
   ################################################################
   exec_fsl \
      fslmaths ${image} \
      -bptf ${hpf} ${lpf} \
      ${maskcall} \
      ${out}
   ################################################################
   # 3a. Filter any derivative 4D timeseries.
   #   * Iterate through all derivative images.
   ################################################################
   exec_sys rm -rf ${out_root}_derivatives
	for derivative in ${derivatives}
      do
      derivative_parse ${derivative}
      #############################################################
      # * Only filter the derivative image if it has the same
      #   number of volumes as the primary image.
      # * Filtering will ensure that derivative timeseries used in
      #   linear models do not re-introduce frequencies that were
      #   filtered out of the primary image.
      #############################################################
	   if [[ ${d_type} == timeseries ]]
	      then
         subroutine           @u.2.4
	      exec_fsl \
	         fslmaths ${d_path} \
            -bptf ${hpf} ${lpf} \
            ${maskcall} \
            ${out_root}_${d_name}.nii.gz
         echo "#${d_name}#${out_root}_${d_name}.nii.gz" \
            >> ${out_root}_derivatives
	   else
         subroutine           @u.2.5
         echo "#${d_name}#${d_path}" \
            >> ${out_root}_derivatives
	   fi
	done
   ################################################################
   # 4a. Filter any 1D timeseries specified by the user.
   #---------------------------------------------------------------
   #   * This is much more complicated than it sounds because
   #     FSL's filter engine will only process NIfTIs.
   #   * So, the information in each 1D timeseries must be written
   #     into a (hopefully compact) NIfTI.
   ################################################################
   for ts in ${tslist}
      do
      subroutine              @u.2.6
      tsname=$(return_field ${ts} -1 '/' 1 '.')
      #############################################################
      # * Determine the number of timeseries in the 1D timeseries
      #   file by dividing the total number of words in the file
      #   by the number of time points (volumes).
      #############################################################
      nfld=$(exec_sys wc -w < ${ts})
      nfld=$(( ${nfld}/${nvol} ))
      #############################################################
      # * Through trial and error, we have found that the desired
      #   result is obtained only if the timeseries is transposed
      #   before conversion to NIfTI.
      #############################################################
      exec_afni 1dtranspose ${ts} ${out_root}_${tsname}_tp.1D
      exec_fsl \
         fslascii2img ${out_root}_${tsname}_tp.1D \
         ${nfld} 1 1 \
         ${nvol} 1 1 1 \
         ${t_rep} \
         ${out_root}_${tsname}.nii.gz
      exec_fsl \
         fslmaths ${out_root}_${tsname}.nii.gz \
         -bptf ${hpf} ${lpf} \
         ${out_root}_${tsname}_filt.nii.gz
      #############################################################
      # * Convert back to a .1D file using fslmeants with the
      #   showall flag to return all timeseries instead of the
      #   mean timeseries.
      #############################################################
      exec_fsl \
         fslmeants -i ${out_root}_${tsname}_filt.nii.gz \
         --showall \
         -o ${out_root}_${tsname}.1D
      rm -f ${out_root}_${tsname}_tp.1D
      rm -f ${out_root}_${tsname}.nii.gz
      rm -f ${out_root}_${tsname}_filt.nii.gz
   done
   ;;
   
   
   
   
   
fft)
   subroutine                 @u.3
   genfilt=0
   is_image ${mask} && maskcall="-mask ${mask}"
   ################################################################
   # 2b. Filter the primary 4D timeseries.
   #---------------------------------------------------------------
   #   * Define the highpass and lowpass inputs to AFNI's
   #     3dBandpass, which performs the FFT decomposition.
   #   * According to the 3dBandpass documentation, setting the
   #     lowpass cutoff to 99999 will remove only frequencies above
   #     the Nyquist limit.
   #   * So, if the user has requested all frequencies retained up
   #     to the Nyquist limit, pass 99999 as the lowpass cutoff.
   ################################################################
   if [[ ${lopass} == nyquist ]]
      then
      subroutine              @u.3.1
      lopass=99999
   fi
   ################################################################
   #   * Apply the FFT filter.
   #   * If the output path is already occupied by an image, then
   #     AFNI will not by default overwrite. Clear the output path.
   ################################################################
   rm -rf ${out}
   exec_afni \
      3dBandpass \
      -prefix ${out} \
      -nodetrend -quiet \
      ${maskcall} \
      ${hipass} ${lopass} ${image} \
      2>/dev/null
   ################################################################
   # 3b. Filter any derivative 4D timeseries.
   ################################################################
   exec_sys rm -rf ${out_root}_derivatives
	for derivative in ${derivatives}
      do
      derivative_parse ${derivative}
      #############################################################
      # * Only filter the derivative image if it has the same
      #   number of volumes as the primary image.
      #############################################################
	   if [[ ${d_type} == timeseries ]]
	      then
         subroutine           @u.3.2
         exec_sys rm -rf ${out_root}_${d_name}.nii.gz
	      exec_afni \
	         3dBandpass \
            -prefix ${out_root}_${d_name}.nii.gz \
            -nodetrend \
            -quiet \
            ${maskcall} \
            ${hipass} ${lopass} \
            ${d_path} \
            &>/dev/null
         echo "#${d_name}#${out_root}_${d_name}.nii.gz" \
            >> ${out_root}_derivatives
      #############################################################
      # * If the derivative image has a different number of volumes
      #   from the primary image, then copy it to the index of
      #   filtered derivatives without making any changes.
      #############################################################
	   else
         subroutine           @u.3.3
         echo "#${d_name}#${d_path}" \
            >> ${out_root}_derivatives
	   fi
	done
   ################################################################
   # 4b. Filter any 1D timeseries specified by the user.
   #---------------------------------------------------------------
   #   * For this purpose, the script uses 1dBandpass.
   #   * Because 1D files do not include a header with timing
   #     information, the repetition time must be provided so that
   #     the program can convert cutoff frequencies to units of
   #     sampling intervals.
   ################################################################
   for ts in ${tslist}
      do
      tsname=$(return_field ${ts} -1 '/' 2 '.')
      exec_sys rm -rf ${out_root}_${tsname}.1D
      exec_afni \
         1dBandpass \
         -nodetrend \
         -dt ${t_rep} \
         ${hipass} ${lopass} ${ts} \
         >> ${out_root}_${tsname}.1D
   done
   ;;
   
   
   
   
   
butterworth)
   subroutine                 @u.4
   genfilt=1
   rpcall=""
   rscall=""
   fcall="-f butterworth"
   ;;
chebyshev1)
   subroutine                 @u.5
   genfilt=1
   rpcall="-p ${rpass}"
   rscall=""
   fcall="-f chebyshev1"
   ;;
chebyshev2)
   subroutine                 @u.6
   genfilt=1
   rpcall=""
   rscall="-s ${rstop}"
   fcall="-f chebyshev2"
   ;;
elliptic)
   subroutine                 @u.7
   genfilt=1
   rpcall="-p ${rpass}"
   rscall="-s ${rstop}"
   fcall="-f elliptic"
   ;;
esac

###################################################################
# genfilter is a utility R script that applies Butterworth,
# Chebyshev I and II, and elliptic filters to an image.
###################################################################
if (( ${genfilt} == 1 ))
   then
   subroutine     @u.8
   ################################################################
   # Initialise parameters.
   ################################################################
   is_image ${mask} && maskcall="-m ${mask}"
   ocall="-r ${order}"
   dcall="-d ${pass}"
   ################################################################
   # Filter the primary 4D timeseries.
   ################################################################
   exec_sys rm -rf ${out}
   exec_xcp \
      genfilter.R \
      -i ${image} \
      -o ${out} \
      ${fcall} \
      ${maskcall} \
      -c ${hipass} \
      -l ${lopass} \
      ${ocall} \
      ${dcall} \
      ${rpcall} \
      ${rscall}
   ################################################################
   # Filter any derivative 4D timeseries.
   ################################################################
   rm -rf ${out_root}_derivatives
   for derivative in ${derivatives}
      do
      derivative_parse ${derivative}
      #############################################################
      # * Only filter the derivative image if it has the same
      #   number of volumes as the primary image.
      #############################################################
	   if [[ ${d_type} == timeseries ]]
	      then
         subroutine  @u.8.1
         ##########################################################
         # * Ensure that the ultimate input to genfilter has an
         #   appropriate extension. Genfilter requires the complete
         #   file name.
         ##########################################################
         exec_xcp \
            genfilter.R \
            -i ${d_path} \
            -o ${out_root}_${d_name}.nii.gz \
            ${fcall} \
            ${maskcall} \
            -c ${hipass} \
            -l ${lopass} \
            ${ocall} \
            ${dcall} \
            ${rpcall} \
            ${rscall}
         echo "#${d_name}#${out_root}_${d_name}.nii.gz" \
            >> ${out_root}_derivatives
      #############################################################
      # * If the derivative image has a different number of volumes
      #   from the primary image, then copy it to the index of
      #   filtered derivatives without making any changes.
      #############################################################
	   else
         subroutine  @u.8.2
         echo "#${d_name}#${d_path}" \
            >> ${out_root}_derivatives
	   fi
	done
   ################################################################
   # Filter any 1D timeseries specified by the user.
   #---------------------------------------------------------------
   #   * For this purpose, the script uses 1dGenfilter.
   #   * Because 1D files do not include a header with timing
   #     information, the repetition time must be provided so that
   #     the program can convert cutoff frequencies to units of
   #     sampling intervals.
   ################################################################
   for ts in ${tslist}
      do
      subroutine  @u.8.3
      tsname=$(return_field ${ts} -1 '/' 1 '.')
      exec_sys rm -rf ${out_root}_${tsname}.1D
      exec_xcp \
         1dGenfilter.R \
         -i ${ts} \
         -o ${out_root}_${tsname}.1D \
         ${fcall} \
         -t ${t_rep} \
         -c ${hipass} \
         -l ${lopass} \
         ${ocall} \
         ${dcall} \
         ${rpcall} \
         ${rscall}
   done
fi





###################################################################
# 5. Finally, it is time to discard volumes from the limits of all
#    timeseries, as specified by the user.
#  * If the number of volumes to be discarded is 0 (default
#    behaviour), then the script will never enter the conditional
#    statement below.
#  * For a forward-only filter, volumes are discarded only from the
#    beginning of each timeseries.
#  * For a forward/reverse filter, volumes are discarded from the
#    beginning and end of each timeseries.
###################################################################
if (( ${dvol} > 0 ))
   then
   subroutine     @u.9
   ################################################################
   # Compute the number of volumes to be retained following
   # timeseries truncation.
   #  * For forward filters, this is equal to the difference
   #    between the number of initial volumes and the number of
   #    volumes to be discarded.
   #  * For forward/reverse filters, this is equal to the
   #    difference between the number of initial volumes and
   #    twice the number of volumes to be discarded, since
   #    that many volumes are to be discarded from both the
   #    beginning and end of the timeseries.
   ################################################################
   case ${pass} in
   1)
      subroutine  @u.9.1
      retain=$(( ${nvol} - ${dvol}))
      echo "Discarding ${dvol} volumes from beginning of"
      echo "  timeseries"
      ;;
   2)
      subroutine  @u.9.2
      retain=$(( ${nvol} - 2*${dvol} ))
      echo "Discarding ${dvol} volumes from beginning and end"
      echo "  of timeseries"
      ;;
   esac
   ################################################################
   # Primary BOLD timeseries:
   #---------------------------------------------------------------
   # Use fslroi to remove the first $dvol volumes and retain
   # the next $retain volumes.
   ################################################################
   exec_fsl \
      fslroi ${out} ${out} \
      0 -1 \
      0 -1 \
      0 -1 \
      ${dvol} ${retain}
   ################################################################
   # Derivative 4D timeseries:
   #---------------------------------------------------------------
   #  * Update the derivatives list by loading in the new list
   #    of filtered derivatives.
   #  * Iterate through all derivatives, obtain their names, and
   #    again use fslroi.
   ################################################################
   derivatives=$(cat ${out_root}_derivatives)
   for derivative in ${derivatives}
      do
      subroutine  @u.9.3
      #############################################################
      # * Parse the derivative image.
      #############################################################
	   derivative_parse ${derivative}
	   if [[ ${d_type} == timeseries ]]
	      then
         subroutine  @u.9.4
	      fsl_exec \
	         fslroi ${d_path} ${d_path} \
            0 -1 \
            0 -1 \
            0 -1 \
            ${dvol} ${retain}
	   fi
	done
   ################################################################
   # 1D timeseries:
   #---------------------------------------------------------------
   #  * First, update the pointer to indicate the filtered
   #    version of each timeseries.
   ################################################################
   for ts in ${tslist}
      do
      subroutine  @u.9.5
      #############################################################
      # * Obtain the base name of the old 1D timeseries file; use
      #   this to find the path to the filtered version of
      #   the same timeseries.
      # * Discard volumes from the timeseries limits.
      #############################################################
      tsname=$(return_field ${ts} -1 '/' 1 '.')
      ts=${out_root}_${tsname}.1D
      exec_sys tail -n +${dvol} ${ts} >> ${out_root}_TEMP_ts
      exec_sys rm -f ${ts}
      exec_sys head -n ${retain} ${out_root}_TEMP_ts >> ${ts}
      exec_sys rm -f ${out_root}_TEMP_ts
   done
   ################################################################
   # Temporal mask:
   #---------------------------------------------------------------
   #  * The temporal mask, too, must be truncated so that its
   #    indices correctly match up with any new volumes.
   ################################################################
   tmask=${tmaskcut}
   if [[ ${tmask} != "ones" ]]
      then
      subroutine  @u.9.6
      tail -n +${dvol} ${tmask} >> ${out_root}_TEMP_tmask
      head -n ${retain} ${out_root}_TEMP_tmask >> ${out_root}_tmask.1D
      rm -f ${out_root}_TEMP_tmask
   fi
fi
