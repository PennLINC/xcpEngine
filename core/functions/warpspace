warpspace() {
   local a_chk       a_edges     d_chk       d_edges     e \
         edges       f_chk       f_edges     i           k \
         layer       n           node_chk    nodes       o \
         objects     output      route       source      t \
         target      v           x           xfm
   declare -A        s           d           a
   ################################################################
   # [1] PARSE INPUTS
   #---------------------------------------------------------------
   # i         Image to be warped
   # o         Output path for warped image
   # n         Interpolation scheme
   # v         voxel (0) OR mm (1) coordinates
   # target    Target space to warp to
   ################################################################
   i=${1}
   o=${2}
   v='-l'
   target=( ${3//:/ } )
   if [[ -n ${target[1]} ]]
      then
      source=${target[0]}
      target=${target[1]}
   else
      target=${target[0]}
      #############################################################
      #     Determine the coordinate space of origin, if it has not
      #     been passed explicitly.
      #
      #     Case 1: The input is an atlas.
      #############################################################
      if contains ${i} "atlas:"
         then
         i=${i//atlas:/}
         atlas_parse ${i}
         source=${a[Space]}
         i=${a[Map]}
      #############################################################
      #     Case 2: The input is a derivative.
      #############################################################
      elif ! is_image ${i}
         then
         source=$(   json_query  ${i}  Space    "${aux_imgs[sub]}")
         i=$(        json_query  ${i}  Map      "${aux_imgs[sub]}")
      #############################################################
      #     Case 3: The source is otherwise unspecified. Default to
      #     analyte space.
      #############################################################
      else
         source=${space[sub]}
      fi
      i=$(eval echo ${i})
   fi
   if [[ -n ${4} ]]
      then
      (( ${4} == 0 )) && unset v
      n="-n ${4}"
   fi
   ################################################################
   # [2] PARSE SPATIAL METADATA
   #---------------------------------------------------------------
   #        Parse available spaces (nodes) and transforms (edges)
   ################################################################
   objects=$(cat  ${spaces[sub]}   |$JQ_PATH      'keys[]')
   for k    in    $objects
      do
      #############################################################
      #     Determine whether each object in the spatial metadata
      #     is a space or a transform. Spaces include the 'Map'
      #     property, while transforms do not.
      #############################################################
      node_chk=$( json_query  ${k}  Map               ${spaces[sub]})
      k=${k//\"/}
      #############################################################
      #     Add spaces to the list of available nodes.
      #     First ensure that the space is not already listed.
      #############################################################
      if [[       -n ${node_chk} ]]
         then
         k=${k//\%*/}
         [[ ${nodes//${k}/} == ${nodes} ]] && nodes="${nodes} ${k}"
      #############################################################
      #     Add transforms to the list of available edges.
      #     First ensure that the transform is not already listed.
      #############################################################
      else
         [[ ${edges//${k}/} == ${edges} ]] && edges="${edges} ${k}" || continue
         ##########################################################
         #  TODO
         #  Multilayer matrix support. Transforms contributed by
         #  different programs should be routed differently.
         ##########################################################
         a_chk=$( json_query  \"${k}\"  TransformANTs     ${spaces[sub]})
         f_chk=$( json_query  \"${k}\"  TransformFSL      ${spaces[sub]})
         d_chk=$( json_query  \"${k}\"  TransformDRAMMS   ${spaces[sub]})
         if [[    -n ${a_chk}    ]]
            then
            a_edges="${a_edges} ${k}"
         fi
         if [[    -n ${f_chk}    ]]
            then
            f_edges="${a_edges} ${k}"
         fi
         if [[    -n ${d_chk}    ]]
            then
            d_edges="${a_edges} ${k}"
         fi
      fi
   done
   ################################################################
   # [3] ROUTE TRANSFORM
   #---------------------------------------------------------------
   #        Determine the shortest route from the source space to
   #        the target space.
   #
   #        This routing uses Dijkstra's algorithm on the graph
   #        defined from the metadata above.
   ################################################################
   nodes=$(echo $nodes)
   edges=$(echo $edges)
   nodes=${nodes// /,}
   edges=${edges// /,}
   ################################################################
   #        If the source and target spaces are identical, then
   #        apply only the identity transform.
   ################################################################
   if [[ ${source//\%*/} == ${target//\%*/} ]]
      then
      route=()
   ################################################################
   #        Determine whether the input is an image or a coordinate
   #        If it's an image, use the forward transforms.
   ################################################################
   elif is_image ${i}
      then
      route=( $(${XCPEDIR}/utils/warprouter.R \
         -n ${nodes} \
         -e ${edges} \
         -s ${source//\%*/} \
         -t ${target//\%*/}) )
   ################################################################
   #        If it's a coordinate, use the inverse transforms.
   ################################################################
   else
      route=( $(${XCPEDIR}/utils/warprouter.R \
         -n ${nodes} \
         -e ${edges} \
         -s ${target//\%*/} \
         -t ${source//\%*/}) )
   fi
   ################################################################
   # [4] EXECUTE TRANSFORM
   #---------------------------------------------------------------
   #        Obtain the target reference and perform the warp.
   ################################################################
   target=$(json_query \"${target}\" Map ${spaces[sub]})
   target=$(eval echo ${target})
   layer=${route[0]}
   route=( "${route[@]:1}" )
   ################################################################
   #        Determine whether input is an image or a coordinate.
   #        If it's an image, use antsApplyTransforms.
   ################################################################
   if is_image ${i}
      then
      for e in "${route[@]}"
         do
         t=$(json_query \"${e}\" TransformANTs ${spaces[sub]})
         t=$(echo ${t}|${JQ_PATH} --raw-output '.[]')
         for x in ${t}
            do
            x=$(eval echo ${x})
            xfm="-t ${x} ${xfm}"
         done
      done
      exec_ants antsApplyTransforms -e 3 -d 3 \
         -i ${i}  -r    ${target} \
         -o ${o}  ${n}  ${xfm}
   ################################################################
   #        If it's a coordinate, use pointTransform.
   #        Note that this is routed backwards.
   #        Also note that a reference image is required for the
   #        source.
   ################################################################
   else
      source=$(json_query \"${source}\" Map ${spaces[sub]})
      source=$(eval echo ${source})
      for e in "${route[@]}"
         do
         t=$(json_query \"${e}\" TransformANTs ${spaces[sub]})
         t=$(echo ${t}|${JQ_PATH} --raw-output '.[]')
         for x in ${t}
            do
            x=$(eval echo ${x})
            xfm="${xfm} -t ${x}"
         done
      done
      rm -f ${o}
      exec_xcp pointTransform \
         -v ${v}        -i ${i} \
         -s ${source}   -r ${target} \
         ${xfm}         >> ${o}
   fi
}
